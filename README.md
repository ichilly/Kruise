# Kruise
A deployment file generation service for kubernetes.

## Purpose of the project
This project aims to simplify the kubernetes deployment file editing flow by accepting a request with simple app info and returing an all-in-one yaml file which can be deployed at once. 

## Developer Guide

### 1. How to create the project
This project is generated by [swagger](https://swagger.io/):
```
swagger generate server -t ../Kruise -f swagger.yaml -A Service-Configurator
```

> The ```cmd```, ```models``` and ```restapi``` folders can be updated by editing the ```swagger.yaml``` file. <br/>
> [Swagger editor](https://editor.swagger.io/) is recommended.

### 2. How to test the project
The ```main.go``` file in ```cmd``` folder is the main entry of this project.
```
go run cmd/service-configurator-server/main.go serve --port 5000
```

### 3. What's the structure of the project
```Renderers``` in controllers folder can render kubernetes objects in different kinds. <br/>
```Defaults setters``` in controllers folder can load default values for different kubernetes objects. <br/>
The ```/v1/app/configs``` API defined in ```restapi/configure_service_configurator.go``` allows users to ```POST``` a json object of their app description and returns an all-in-one kubernetes deployment files in yaml format. <br/>

### 4. Design assumptions
1. Each app contains ```only 1 service``` and multiple containers.
2. Each deployment file contains 1 ```main service container``` with has the same name as the app.
3. Swagger ui is deployed at "swagger-ui:8080", and it's ingress is configured as "http://ingressdomain.com/swagger".
4. The api endpoint and swagger doc of the service are exposed by ```Ingress``` objects, and service docs can be found by visiting "http://ingressdomain.com/swagger?url=docslink".
5. All ```Secret``` objects are added to kubernetes prior to service deployment, so this project won't generate secret files.
6. The all-in-one yaml generated by the service is a ```recommended deployment file```, but users may still customize it for deployment.
7. Pre-filled default values can be modified based on environment or best practice. 

## User Guide
### 1. Make a request with app info
This is a sample request which contains mock-up service meta:
```
POST /v1/app/configs
Body:
{
  "component": {
    "containers": [
      {
        "image": "ichilly/myservice-image",
        "env": {
          "values": [
            {
              "name": "MYSQL_USER",
              "value": "my-service"
            },
            {
              "name": "MYSQL_DBNAME",
              "value": "mysql"
            }
          ],
          "valueFroms": [
            {
              "name": "MYSQL_PASSWORD",
              "valueRef": {
                "type": "secretKeyRef",
                "name": "mysql-secret",
                "key": "MYSQL_PASSWORD"
              }
            }
          ]
        },
        "volumeMounts": [
          {
            "name": "cors-conf",
            "configMap": "configmap-cors",
            "mountPath": "/mnt/cors",
            "readOnly": true
          }
        ]
      }
    ],
    "service": {
      "ports": [
        {
          "targetPort": 80
        }
      ]
    }
  },
  "metadata": {
    "app": "my-service",
    "version": "v0.0.1-beta",
    "env": "INT",
    "dependencies": {
    	"mysql": true,
    	"aws": false
    },
    "plugins": {
    	"swagger": true
    }
  }
}
```
Explanations of the request body:
1. Service name/App name is: my-service.
2. My service depends on mysql and aws, whose default configs will be loaded.
3. My service wishes to load swagger container as its sidecar container(called plugin here).
4. My service is running on port 80, which will also be mapped to targetPort 80 by default.
5. My service container has some customized key/value and valueFrom env settings.
6. My service container mounts configmap-cors to its /mnt/cors folder for cors handling.

### 2. Understand the response
Response:
```
apiVersion: v1
kind: Service
metadata:
  name: my-service
  namespace: default
  labels:
    app: my-service
    version: v0.0.1-beta
spec:
  ports:
  - name: my-service
    port: 80
    targetPort: 80
  selector:
    app: my-service
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-service
  namespace: default
  labels:
    app: my-service
    version: v0.0.1-beta
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: my-service
  template:
    metadata:
      labels:
        app: my-service
    spec:
      containers:
      - name: my-service
        image: ichilly/myservice-image:v0.0.1-beta
        imagePullPolicy: Always
        ports:
        - name: my-service
          containerPort: 80
        env:
        - name: MYSQL_USER
          value: "my-service"
        - name: MYSQL_DBNAME
          value: "mysql"
        - name: HOST
          value: "0.0.0.0"
        - name: PORT
          value: "80"
        - name: MYSQL_HOST
          value: "mysql-service"
        - name: MYSQL_PORT
          value: "3306"
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: MYSQL_PASSWORD
        volumeMounts:
        - name: cors-conf
          mountPath: /mnt/cors
          readOnly: true
      volumes:
      - name: cors-conf
        configMap:
          name: configmap-cors
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: my-service-docs-ingress
  namespace: default
  annotations:
    kubernetes.io/ingress.class: "nginx"
    nginx.ingress.kubernetes.io/rewrite-target: "http://ingressdomain.com/swagger?url=https://docs.s3.us-east-1.amazonaws.com/swagger/INT/my-service/swagger.json"
spec:
  tls:
    - secretName: tls-secret
  rules:
    - http:
        paths:
          - path: /my-service/docs
            backend:
              serviceName: swagger-ui
              servicePort: 8080
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: my-service-api-ingress
  namespace: default
  annotations:
    kubernetes.io/ingress.class: "nginx"
    nginx.ingress.kubernetes.io/rewrite-target: /$2
spec:
  tls:
    - secretName: tls-secret
  rules:
    - http:
        paths:
          - path: /my-service/apis(/|$)(.*)
            backend:
              serviceName: my-service
              servicePort: 80
``` 
Explanations of the response body:
1. ```Service``` and ```Deployment``` objects are configured for ```my-service```. 
2. Service document ingress is configured to display online(e.g. AWS S3) docs in swagger ui.
3. Two ```Ingress``` objects have been configured to expose my-service API endpoint and swagger UI endpoint. 
4. Default values have been loaded in yaml files for deployment.

### 3. Deploy the all-in-one yaml file
Users can save the response to a yaml file and run ```kubectl apply``` command or integrate this command to a CD service to deploy their services.
```
kubectl apply -f all-in-one.yaml
```
