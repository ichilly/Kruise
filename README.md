# Kruise
A deployment file generation service for kubernetes.

## Purpose of the project
This project aims to simplify the kubernetes deployment file editing flow by accepting a request with simple app info and returing an all-in-one yaml file which can be deployed at once. 

## Developer Guide

### 1. How to create the project
This project is generated by [swagger](https://swagger.io/):
```
swagger generate server -t Kruise -f ./swagger/swagger.yml -A service-configurator
```

> The ```cmd```, ```models``` and ```restapi``` folders can be updated by editing the ```swagger.yaml``` file. <br/>
> [Swagger editor](https://editor.swagger.io/) is recommended.

### 2. How to test the project
The ```main.go``` file in ```cmd``` folder is the main entry of this project.
```
go run cmd/service-configurator-server/main.go serve --port 5000
```

### 3. What's the structure of the project
```Renderers``` in controllers folder can render kubernetes objects in different kinds. <br/>
```Defaults setters``` in controllers folder can load default values for different kubernetes objects. <br/>
The ```/v1/app/configs``` API defined in ```restapi/configure_service_configurator.go``` allows users to ```POST``` a json object of their app description and returns an all-in-one kubernetes deployment files in yaml format. <br/>

### 4. Design assumptions
1. Each app contains ```only 1 service``` and multiple containers.
2. Each deployment file contains 1 ```main service container``` with has the same name as the app
3. Swagger ui container will be added as a ```sidecar container``` by default.
4. Both the api endpoint and swagger ui endpoint are exposed by ```Ingress``` objects.
5. Each container will use an ```initContainer``` to load secrets from a secret service. Secrets won't be deployed as kubernetes secret objects to enhance security.
6. The yamls generated by the service is a ```recommended deployment file```, but users may still customize it for deployment.
7. Pre-filled default values can be modified based on best practices and requirements. 

## User Guide
### 1. Make a request with app info
This is a sample request which contains mock-up service meta:
```
POST /v1/app/configs
Body:
{
  "component": {
    "containers": [
      {
        "image": "ichilly/myservice-image",
        "env": {
          "values": [
            {
              "name": "MYSQL_USER",
              "value": "my-service"
            },
            {
              "name": "MYSQL_DBNAME",
              "value": "mysql"
            }
          ],
          "valueFroms": [
            {
              "name": "MYSQL_PASSWORD",
              "valueRef": {
                "type": "secretKeyRef",
                "name": "mysql-secret",
                "key": "MYSQL_PASSWORD"
              }
            }
          ]
        }
      }
    ],
    "service": {
      "ports": [
        {
          "targetPort": 80
        }
      ]
    }
  },
  "metadata": {
    "app": "my-service",
    "version": "v0.0.1-beta",
    "env": "INT",
    "dependencies": {
    	"mysql": true,
    	"aws": false
    },
    "plugins": {
    	"swagger": true
    }
  }
}
```
Explanations of the request body:
1. Service name/App name is: my-service.
2. My service depends on mysql and aws, whose default configs will be loaded.
3. My service wishes to load swagger container as its sidecar container(called plugin here).
4. My service is running on port 80, which will also be mapped to targetPort 80 by default.
5. My service container has some customized key/value and valueFrom env settings.

### 2. Understand the response
Response:
```
apiVersion: v1
kind: Service
metadata:
  name: my-service
  namespace: default
  labels:
    app: my-service
    version: v0.0.1-beta
spec:
  ports:
  - name: my-service
    port: 80
    targetPort: 80
  - name: swagger
    port: 8080
    targetPort: 8080
  selector:
    app: my-service
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-service
  namespace: default
  labels:
    app: my-service
    version: v0.0.1-beta
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: my-service
  template:
    metadata:
      labels:
        app: my-service
    spec:
      containers:
      - name: my-service
        image: ichilly/myservice-image:v0.0.1-beta
        imagePullPolicy: Always
        ports:
        - name: my-service
          containerPort: 80
        env:
        - name: MYSQL_USER
          value: "my-service"
        - name: MYSQL_DBNAME
          value: "mysql"
        - name: HOST
          value: "0.0.0.0"
        - name: PORT
          value: "80"
        - name: MYSQL_HOST
          value: "mysql-service"
        - name: MYSQL_PORT
          value: "3306"
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: MYSQL_PASSWORD
      - name: swagger
        image: swaggerapi/swagger-ui:latest
        imagePullPolicy: Always
        ports:
        - name: swagger
          containerPort: 8080
        env:
        - name: SWAGGER_ROOT
          valueFrom:
            configMapKeyRef:
              name: swagger-config
              key: swagger.json
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: my-service-docs-ingress
  namespace: default
  annotations:
    kubernetes.io/ingress.class: "nginx"
    nginx.ingress.kubernetes.io/rewrite-target: /$2
spec:
  tls:
    - secretName: tls-secret
  rules:
    - http:
        paths:
          - path: /my-service/docs(/|$)(.*)
            backend:
              serviceName: my-service
              servicePort: 8080
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: my-service-api-ingress
  namespace: default
  annotations:
    kubernetes.io/ingress.class: "nginx"
    nginx.ingress.kubernetes.io/rewrite-target: /$2
spec:
  tls:
    - secretName: tls-secret
  rules:
    - http:
        paths:
          - path: /my-service/apis(/|$)(.*)
            backend:
              serviceName: my-service
              servicePort: 80
``` 
Explanations of the response body:
1. ```Service``` and ```Deployment``` objects are configured for ```my-service```. 
2. Swagger container is added to deployment containers as a sidecar.
3. 2 ```Ingress``` objects have been configured to expose my-service API endpoint and swagger UI endpoint. 
4. Default values have been loaded in yaml files for deployment.

### 3. Deploy the all-in-one yaml file
Users can save the response to a yaml file and run ```kubectl apply``` command or integrate this command to a CD service to deploy their services.
```
kubectl apply -f all-in-one.yaml
```